#!/usr/bin/env python3

import logging
import datetime
import re
import enum
import os
from bs4.element import Script
from pycaching import errors
from pycaching.geo import Point
from pycaching.trackable import Trackable
from pycaching.log import Log, Type as LogType
from pycaching.util import parse_date, rot13, lazy_loaded

# prefix _type() function to avoid collisions with cache type
_type = type


class Cache(object):
    """Represents a geocache with its properties and methods for loading them.

    Provides some getters and setters for geocache properties like name, size, terrain, etc.
    Also contains two possibile methods to load cache details and ensures, that these methods
    are called when accessing a property which hasn't been filled yet.

    There are also methods for posting and loadings logs here. For more detail about Logs, please
    refer to :class:`.Log`.

    In summary, this class contains everything, which is possible to see or do on geocache page
    on geocaching.com.
    """

    # generated by util.get_possible_attributes()
    # TODO: smarter way of keeping attributes up to date
    _possible_attributes = {
        "abandonedbuilding": "Abandoned Structure",
        "uv": "UV Light Required",
        "available": "Available at all times",
        "bicycles": "Bicycles",
        "boat": "Boat",
        "campfires": "Campfires",
        "camping": "Camping available",
        "cliff": "Cliff / falling rocks",
        "climbing": "Difficult climbing",
        "cow": "Watch for livestock",
        "danger": "Dangerous area",
        "dangerousanimals": "Dangerous animals",
        "dogs": "Dogs",
        "fee": "Access or parking fee",
        "field_puzzle": "Field Puzzle",
        "firstaid": "Needs maintenance",
        "flashlight": "Flashlight required",
        "food": "Food Nearby",
        "frontyard": "Front Yard (Private Residence)",
        "fuel": "Fuel Nearby",
        "geotour": "Geotour",
        "hike_long": "Long Hike (+10km)",
        "hike_med": "Medium hike (1km-10km)",
        "hike_short": "Short hike (less than 1km)",
        "hiking": "Significant hike",
        "horses": "Horses",
        "hunting": "Hunting",
        "jeeps": "Off-road vehicles",
        "kids": "Recommended for kids",
        "landf": "Lost And Found Tour",
        "mine": "Abandoned mines",
        "motorcycles": "Motorcycles",
        "night": "Recommended at night",
        "nightcache": "Night Cache",
        "onehour": "Takes less than one hour",
        "parking": "Parking available",
        "parkngrab": "Park and Grab",
        "partnership": "Partnership Cache",
        "phone": "Telephone nearby",
        "picnic": "Picnic tables nearby",
        "poisonoak": "Poison plants",
        "public": "Public transportation",
        "quads": "Quads",
        "rappelling": "Climbing gear",
        "restrooms": "Public restrooms nearby",
        "rv": "Truck Driver/RV",
        "s-tool": "Special Tool Required",
        "scenic": "Scenic view",
        "scuba": "Scuba gear",
        "seasonal": "Seasonal Access",
        "skiis": "Cross Country Skis",
        "snowmobiles": "Snowmobiles",
        "snowshoes": "Snowshoes",
        "stealth": "Stealth required",
        "strike": "Not allowed",
        "stroller": "Stroller accessible",
        "swimming": "May require swimming",
        "teamwork": "Teamwork Required",
        "thorn": "Thorns",
        "ticks": "Ticks",
        "touristok": "Tourist Friendly",
        "treeclimbing": "Tree Climbing",
        "wading": "May require wading",
        "water": "Drinking water nearby",
        "wheelchair": "Wheelchair accessible",
        "winter": "Available during winter",
        "wirelessbeacon": "Wireless Beacon"
    }

    # collection of urls used within the Cache class
    _urls = {
        "tiles_server": "http://tiles01.geocaching.com/map.details",
        "logbook": "seek/geocache.logbook",
        "cache_details": "seek/cache_details.aspx",
        "print_page": "seek/cdpf.aspx",
        "log_page": "play/geocache/{wp}/log",
    }

    @classmethod
    def _from_print_page(cls, geocaching, guid, soup):
        """Create a cache instance from a souped print-page and a GUID."""
        if soup.find("p", "Warning") is not None:
            raise errors.PMOnlyException()

        cache_info = dict()
        cache_info["guid"] = guid
        cache_info["wp"] = soup.find(class_="HalfRight").find("h1").text.strip()
        content = soup.find(id="Content")
        cache_info["name"] = content.find("h2").text.strip()
        cache_info["type"] = Type.from_filename(content.h2.img["src"].split("/")[-1].partition(".")[0])
        cache_info["author"] = content.find(class_="Meta").text.partition(":")[2].strip()
        diff_terr = content.find(class_="DiffTerr").find_all("img")
        assert len(diff_terr) == 2
        cache_info["difficulty"] = float(diff_terr[0]["alt"].split()[0])
        cache_info["terrain"] = float(diff_terr[1]["alt"].split()[0])
        cache_info["size"] = Size.from_string(content.find(class_="Third AlignCenter").p.img["alt"].partition(":")[2])
        fav_text = content.find(class_="Third AlignRight").p.contents[2]
        try:
            cache_info["favorites"] = int(fav_text)
        except ValueError:  # element not present when 0 favorites
            cache_info["favorites"] = 0
        cache_info["hidden"] = parse_date(
            content.find(class_="HalfRight AlignRight").p.text.strip().partition(":")[2].strip())
        cache_info["location"] = Point.from_string(content.find(class_="LatLong").text.strip())
        cache_info["state"] = None  # not on the page
        attributes = [img["src"].split("/")[-1].partition(".")[0].rpartition("-")
                      for img in content.find(class_="sortables").find_all("img")
                      if img.get("src") and img["src"].startswith("/images/attributes/")]
        cache_info["attributes"] = {attr_name: attr_setting == "yes"
                                    for attr_name, _, attr_setting in attributes}
        if "attribute" in cache_info["attributes"]:  # 'blank' attribute
            del cache_info["attributes"]["attribute"]
        cache_info["summary"] = content.find("h2", text="Short Description").find_next("div").text
        cache_info["description"] = content.find("h2", text="Long Description").find_next("div").text
        hint = content.find(id="uxEncryptedHint")
        cache_info["hint"] = hint.text.strip() if hint else None
        cache_info["waypoints"] = Waypoint.from_html(content, table_id="Waypoints")
        cache_info["log_counts"] = Cache._get_log_counts_from_print_page(soup)
        return Cache(geocaching, **cache_info)

    def __init__(self, geocaching, wp, **kwargs):
        """Create a cache instance.

        :param .Geocaching geocaching: Reference to :class:`.Geocaching` instance, used for loading
            cache data.
        :param str wp: Cache GC Code, eg. "GC1PAR2".
        :param **kwargs: Other cache properties. For possible keywords, please see class properites.
        """

        self.geocaching = geocaching
        if wp is not None:
            self.wp = wp

        known_kwargs = {"name", "type", "location", "original_location", "state", "found", "size",
                        "difficulty", "terrain", "author", "hidden", "attributes", "summary",
                        "description", "hint", "favorites", "pm_only", "url", "waypoints", "_logbook_token",
                        "_trackable_page_url", "guid", "visited", "log_counts"}

        for name in known_kwargs:
            if name in kwargs:
                setattr(self, name, kwargs[name])

    def __str__(self):
        """Return cache GC code."""
        return self._wp  # not to trigger lazy_loading !

    def __eq__(self, other):
        """Compare caches by their GC code and contained :class:`.Geocaching` reference."""
        return self.geocaching == other.geocaching and self.wp == other.wp

    @classmethod
    def from_trackable(cls, trackable):
        """Return :class:`.Cache` instance from :class:`.Trackable`.

        This only makes sense, if trackable is currently placed in cache. Otherwise it will have
        unexpected behavior.

        :param .Trackable trackable: Source trackable.
        """
        # TODO handle trackables which are not in cache
        return cls(trackable.geocaching, None, url=trackable.location_url)

    @classmethod
    def from_block(cls, block):
        """Return :class:`.Cache` instance from :class:`.Block`.

        Used during quick search. The Cache will have only GC code, name and approximate location
        filled in.

        :param .Block block: Source block
        """
        c = cls(block.tile.geocaching, block.cache_wp, name=block.cache_name)
        c.location = Point.from_block(block)
        return c

    @property
    def wp(self):
        """The cache GC code, must start with :code:`GC`.

        :type: :class:`str`
        """
        return self._wp

    @wp.setter
    def wp(self, wp):
        wp = str(wp).upper().strip()
        if not wp.startswith("GC"):
            raise errors.ValueError("GC code '{}' doesn't start with 'GC'.".format(wp))
        self._wp = wp

    @property
    def guid(self):
        """The cache GUID. An identifier used at some places on geoaching.com

        :type: :class:`str`
        """
        return getattr(self, "_guid", None)

    @guid.setter
    def guid(self, guid):
        guid = guid.strip()
        guid_regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"
        if not re.match(guid_regex, guid):
            raise errors.ValueError("GUID not well formatted: {}".format(guid))
        self._guid = guid

    @property
    def geocaching(self):
        """A reference to :class:`.Geocaching` used for communicating with geocaching.com.

        :type: :class:`.Geocaching` instance
        """
        return self._geocaching

    @geocaching.setter
    def geocaching(self, geocaching):
        if not hasattr(geocaching, "_request"):
            raise errors.ValueError("Passed object (type: '{}')"
                                    "doesn't contain '_request' method.".format(_type(geocaching)))
        self._geocaching = geocaching

    @property
    @lazy_loaded
    def name(self):
        """A human readable name of cache.

        :type: :class:`str`
        """
        return self._name

    @name.setter
    def name(self, name):
        name = str(name).strip()
        self._name = name

    @property
    @lazy_loaded
    def location(self):
        """The cache location.

        :setter: Set a cache location. If :class:`str` is passed, then :meth:`.Point.from_string`
            is used and its return value is stored as a location.
        :type: :class:`.Point`
        """
        return self._location

    @location.setter
    def location(self, location):
        if isinstance(location, str):
            location = Point.from_string(location)
        elif not isinstance(location, Point):
            raise errors.ValueError(
                "Passed object is not Point instance nor string containing coordinates.")
        self._location = location

    @property
    @lazy_loaded
    def original_location(self):
        """The cache original location.

        :setter: Set a cache original location. If :class:`str` is passed, then
        :meth:`.Point.from_string` is used and its return value is stored as a location.
        :type: :class:`.Point`
        """
        return self._original_location

    @original_location.setter
    def original_location(self, original_location):
        if isinstance(original_location, str):
            original_location = Point.from_string(original_location)
        elif not isinstance(original_location, Point) and original_location is not None:
            raise errors.ValueError(
                "Passed object is not Point instance nor string containing coordinates.")
        self._original_location = original_location

    @property
    @lazy_loaded
    def waypoints(self):
        """Any waypoints listed in the cache.

        :setter: Store a dictionary of locations using their lookup.
        :type: :class:`dict`
        """
        return self._waypoints

    @waypoints.setter
    def waypoints(self, waypoints):
        self._waypoints = waypoints

    @property
    @lazy_loaded
    def type(self):
        """The cache type.

        :setter: Set a cache type. If :class:`str` is passed, then :meth:`.cache.Type.from_string`
            is used and its return value is stored as a type.
        :type: :class:`.cache.Type`
        """
        return self._type

    @type.setter
    def type(self, type):
        if not isinstance(type, Type):
            type = Type.from_string(type.strip())
        self._type = type

    @property
    @lazy_loaded
    def state(self):
        """The cache status.

        :code:`True` if cache is enabled, :code:`False` if cache is disabled.

        :type: :class:`bool`
        """
        return self._state

    @state.setter
    def state(self, state):
        self._state = bool(state)

    @property
    @lazy_loaded
    def found(self):
        """The cache found status.

        :code:`True` if cache is found by current user, :code:`False` if not.

        :type: :class:`bool`
        """
        if self._found_status:
            return self._found_status.type in (LogType.found_it, LogType.attended)
        else:
            return False

    @found.setter
    def found(self, found_status):
        if bool(found_status):
            # TODO set found_it / attended based on cache type
            self._found_status = Log(type=LogType.found_it)
        else:
            self._found_status = None

    @property
    @lazy_loaded
    def size(self):
        """The cache size.

        :setter: Set a cache size. If :class:`str` is passed, then :meth:`.cache.Size.from_string`
            is used and its return value is stored as a size.
        :type: :class:`.cache.Size`
        """
        return self._size

    @size.setter
    def size(self, size):
        if not isinstance(size, Size):
            size = Size.from_string(size)
        self._size = size

    @property
    @lazy_loaded
    def difficulty(self):
        """The cache difficulty.

        :setter: Set a cache difficulty. It must be in a common range - 1 to 5 in 0.5 steps.
        :type: :class:`float`
        """
        return self._difficulty

    @difficulty.setter
    def difficulty(self, difficulty):
        if isinstance(difficulty, str):
            difficulty = difficulty.strip().replace(",", ".")
        difficulty = float(difficulty)
        if difficulty < 1 or difficulty > 5 or difficulty * 10 % 5 != 0:  # X.0 or X.5
            raise errors.ValueError("Difficulty must be from 1 to 5 and divisible by 0.5.")
        self._difficulty = difficulty

    @property
    @lazy_loaded
    def terrain(self):
        """The cache terrain.

        :setter: Set a cache terrain. It must be in a common range - 1 to 5 in 0.5 steps.
        :type: :class:`float`
        """
        return self._terrain

    @terrain.setter
    def terrain(self, terrain):
        if isinstance(terrain, str):
            terrain = terrain.strip().replace(",", ".")
        terrain = float(terrain)
        if terrain < 1 or terrain > 5 or terrain * 10 % 5 != 0:  # X.0 or X.5
            raise errors.ValueError("Terrain must be from 1 to 5 and divisible by 0.5.")
        self._terrain = terrain

    @property
    @lazy_loaded
    def author(self):
        """The cache author.

        :type: :class:`str`
        """
        return self._author

    @author.setter
    def author(self, author):
        author = str(author).strip()
        self._author = author

    @property
    @lazy_loaded
    def hidden(self):
        """The cache hidden date.

        :setter: Set a cache hidden date. If :class:`str` is passed, then :meth:`.util.parse_date`
            is used and its return value is stored as a date.
        :type: :class:`datetime.date`
        """
        return self._hidden

    @hidden.setter
    def hidden(self, hidden):
        if isinstance(hidden, str):
            hidden = parse_date(hidden)
        elif not isinstance(hidden, datetime.date):
            raise errors.ValueError(
                "Passed object is not datetime.date instance nor string containing a date.")
        self._hidden = hidden

    @property
    def visited(self):
        """The cache log date (filled by function geocaching.my_logs() if cache is created there)

        :setter: Set a cache log date. If :class:`str` is passed, then :meth:`.util.parse_date`
            is used and its return value is stored as a date.
        :type: :class:`datetime.date`
        """
        return self._visited

    @visited.setter
    def visited(self, visited):
        if isinstance(visited, str):
            visited = parse_date(visited)
        elif not isinstance(visited, datetime.date):
            raise errors.ValueError(
                "Passed object is not datetime.date instance nor string containing a date.")
        self._visited = visited

    @property
    @lazy_loaded
    def attributes(self):
        """The cache attributes.

        :setter: Set a cache attributes. Walk through passed :class:`dict` and use :class:`str`
            keys as attribute names and :class:`bool` values as positive / negative attributes.
            Unknown attributes are ignored with warning (you can find possible attribute keys
            in :attr:`.Cache._possible_attributes`).
        :type: :class:`dict`
        """
        return self._attributes

    @attributes.setter
    def attributes(self, attributes):
        if not isinstance(attributes, dict):
            raise errors.ValueError("Attribues is not dict.")

        self._attributes = {}
        for name, allowed in attributes.items():
            name = name.strip().lower()
            if name in self._possible_attributes:
                self._attributes[name] = allowed
            else:
                logging.warning("Unknown attribute {}, ignoring.".format(name))

    @property
    @lazy_loaded
    def summary(self):
        """The cache text summary.

        :type: :class:`str`
        """
        return self._summary

    @summary.setter
    def summary(self, summary):
        summary = str(summary).strip()
        self._summary = summary

    @property
    @lazy_loaded
    def description(self):
        """The cache long description.

        :type: :class:`str`
        """
        return self._description

    @description.setter
    def description(self, description):
        description = str(description).strip()
        self._description = description

    @property
    @lazy_loaded
    def hint(self):
        """The cache hint.

        :setter: Set a cache hint. Don't decode text, you have to use :meth:`.util.rot13` before.
        :type: :class:`str`
        """
        return self._hint

    @hint.setter
    def hint(self, hint):
        hint = str(hint).strip()
        self._hint = hint

    @property
    @lazy_loaded
    def favorites(self):
        """The cache favorite points.

        :type: :class:`int`
        """
        return self._favorites

    @favorites.setter
    def favorites(self, favorites):
        self._favorites = int(favorites)

    @property
    @lazy_loaded
    def log_counts(self):
        """The log count for each log type.

        :setter: Store a dictionary of log counts for each type used in the logbook of the current
                 cache.
        :type: :class:`dict`
        """
        return self._log_counts

    @log_counts.setter
    def log_counts(self, log_counts):
        self._log_counts = log_counts

    @property
    def pm_only(self):
        """If the cache is PM only.

        :type: :class:`bool`
        """
        return self._pm_only

    @pm_only.setter
    def pm_only(self, pm_only):
        self._pm_only = bool(pm_only)

    @property
    @lazy_loaded
    def _logbook_token(self):
        """The token used to load logbook pages for cache.

        :type: :class:`str`
        """
        return self.__logbook_token

    @_logbook_token.setter
    def _logbook_token(self, logbook_token):
        self.__logbook_token = logbook_token

    @property
    @lazy_loaded
    def _trackable_page_url(self):
        """The URL of page containing all trackables stored in this cache.

        :type: :class:`str`
        """
        return self.__trackable_page_url

    @_trackable_page_url.setter
    def _trackable_page_url(self, trackable_page_url):
        self.__trackable_page_url = trackable_page_url

    def load(self):
        """Load all possible cache details.

        Use full cache details page. Therefore all possible properties are filled in, but the
        loading is a bit slow.

        If you want to load basic details about a PM only cache, the :class:`.PMOnlyException` is
        still thrown, but avaliable details are filled in. If you know, that the cache you are
        loading is PM only, please consider using :meth:`load_quick` as it will load the same
        details, but quicker.

        .. note::
           This method is called automatically when you access a property which isn't yet filled in
           (so-called "lazy loading"). You don't have to call it explicitly.

        :raise .PMOnlyException: If cache is PM only and current user is basic member.
        :raise .LoadError: If cache loading fails (probably because of not existing cache).
        """
        try:
            # pick url based on what info we have right now
            if hasattr(self, "url"):
                root = self.geocaching._request(self.url)
            elif hasattr(self, "_wp"):
                root = self.geocaching._request(self._urls["cache_details"],
                                                params={"wp": self._wp})
            else:
                raise errors.LoadError("Cache lacks info for loading")
        except errors.Error as e:
            # probably 404 during cache loading - cache does not exist
            raise errors.LoadError("Error in loading cache") from e

        # check for PM only caches if using free account
        self.pm_only = root.find("section", "premium-upgrade-widget") is not None

        cache_details = root.find(id="ctl00_divContentMain") if self.pm_only else root.find(id="cacheDetails")

        # details also available for basic members for PM only caches -----------------------------

        if self.pm_only:
            self.wp = cache_details.find("li", "li__gccode").text.strip()

            self.name = cache_details.find("h1").text.strip()

            author = cache_details.find(id="ctl00_ContentBody_uxCacheBy").text
            self.author = author[len("A cache by "):]

            # parse cache detail list into a python list
            details = cache_details.find("ul", "ul__hide-details").text.split("\n")

            self.difficulty = float(details[2])

            self.terrain = float(details[5])

            self.size = Size.from_string(details[8])

            self.favorites = int(details[11])
        else:
            # parse from <title> - get first word
            try:
                self.wp = root.title.string.split(" ")[0]
            except:
                raise errors.LoadError()
            self.name = cache_details.find("h2").text

            self.author = cache_details("a")[1].text

            D_and_T_img = root.find("div", "CacheStarLabels").find_all("img")
            self.difficulty, self.terrain = [float(img.get("alt").split()[0]) for img in D_and_T_img]

            size = root.find("div", "CacheSize")
            size = size.find("img").get("src")  # size img src
            size = size.split("/")[-1].rsplit(".", 1)[0]  # filename w/o extension
            self.size = Size.from_filename(size)

        # use shared functionality as both cases use the same method
        type = cache_details.select_one("svg.cache-icon use").get("xlink:href")  # "cache-types.svg#icon-3-disabled"
        type = type.split("#")[-1].replace("_", "-").split("-")[1]  # "3"
        self.type = Type.from_filename(type)

        if self.pm_only:
            raise errors.PMOnlyException()

        # details not avaliable for basic members for PM only caches ------------------------------
        pm_only_warning = root.find("p", "Warning NoBottomSpacing")
        self.pm_only = pm_only_warning and ("Premium Member Only" in pm_only_warning.text) or False

        attributes_widget, inventory_widget, *_ = root.find_all("div", "CacheDetailNavigationWidget")

        hidden = cache_details.find("div", "minorCacheDetails").find_all("div")[1].text
        self.hidden = parse_date(hidden.split(":")[-1])

        self.location = Point.from_string(root.find(id="uxLatLon").text)

        self.state = root.find("ul", "OldWarning") is None

        log_image = root.find(id="ctl00_ContentBody_GeoNav_logTypeImage")
        if log_image:
            log_image_filename = log_image.get("src").split("/")[-1].rsplit(".", 1)[0]  # filename w/o extension
            self._found_status = Log(type=LogType.from_filename(log_image_filename))
        else:
            self._found_status = None

        attributes_raw = attributes_widget.find_all("img")
        attributes_raw = [_.get("src").split("/")[-1].rsplit("-", 1) for _ in attributes_raw]

        self.attributes = {attribute_name: appendix.startswith("yes") for attribute_name, appendix
                           in attributes_raw if not appendix.startswith("blank")}

        self.summary = root.find(id="ctl00_ContentBody_ShortDescription").text
        self.description = root.find(id="ctl00_ContentBody_LongDescription").text

        self.hint = rot13(root.find(id="div_hint").text.strip())

        favorites = root.find("span", "favorite-value")
        if favorites:
            self.favorites = int(favorites.text)
        else:
            self.favorites = 0

        js_content = "\n".join(root.find_all(string=lambda i: isinstance(i, Script)))
        self._logbook_token = re.findall("userToken\\s*=\\s*'([^']+)'", js_content)[0]
        # find original location if any
        if "oldLatLng\":" in js_content:
            old_lat_long = js_content.split("oldLatLng\":")[1].split(']')[0].split('[')[1]
            self.original_location = Point(old_lat_long)
        else:
            self.original_location = None

        # if there are some trackables
        if len(inventory_widget.find_all("a")) >= 3:
            trackable_page_url = inventory_widget.find(id="ctl00_ContentBody_uxTravelBugList_uxViewAllTrackableItems")
            self._trackable_page_url = trackable_page_url.get("href")[3:]  # has "../" on start
        else:
            self._trackable_page_url = None

        # Additional Waypoints
        self.waypoints = Waypoint.from_html(root, "ctl00_ContentBody_Waypoints")

        # Log counts
        self.log_counts = Cache._get_log_counts_from_cache_details(root)

        logging.debug("Cache loaded: {}".format(self))

    def load_quick(self):
        """Load basic cache details.

        Use information from geocaching map tooltips. Therefore loading is very quick, but
        the only loaded properties are: `name`, `type`, `state`, `size`, `difficulty`, `terrain`,
        `hidden`, `author`, `favorites` and `pm_only`.

        :raise .LoadError: If cache loading fails (probably because of not existing cache).
        """
        res = self.geocaching._request(self._urls["tiles_server"],
                                       params={"i": self.wp},
                                       expect="json")

        if res["status"] == "failed" or len(res["data"]) != 1:
            msg = res["msg"] if "msg" in res else "Unknown error (probably not existing cache)"
            raise errors.LoadError("Cache {} cannot be loaded: {}".format(self, msg))

        data = res["data"][0]

        # prettify data
        self.name = data["name"]
        self.type = Type.from_string(data["type"]["text"])
        self.state = data["available"]
        self.size = Size.from_string(data["container"]["text"])
        self.difficulty = data["difficulty"]["text"]
        self.terrain = data["terrain"]["text"]
        self.hidden = parse_date(data["hidden"])
        self.author = data["owner"]["text"]
        self.favorites = int(data["fp"])
        self.pm_only = data["subrOnly"]
        self.guid = res["data"][0]["g"]

        logging.debug("Cache loaded: {}".format(self))

    def load_by_guid(self):
        """Load cache details using the GUID to request and parse the caches
        'print-page'. Loading as many properties as possible except the
        following ones, since they are not present on the 'print-page':

          + original_location
          + state
          + found
          + pm_only

        :raise .PMOnlyException: If the PM only warning is shown on the page
        """
        # If GUID has not yet been set, load it using the "tiles_server"
        # utilizing `load_quick()`
        if not self.guid:
            self.load_quick()

        res = self.geocaching._request(self._urls["print_page"],
                                       params={"guid": self.guid})
        if res.find("p", "Warning") is not None:
            raise errors.PMOnlyException()
        content = res.find(id="Content")

        self.name = content.find("h2").text

        self.location = Point.from_string(
            content.find("p", "LatLong Meta").text)

        type_img = os.path.basename(content.find("img").get("src"))
        self.type = Type.from_filename(os.path.splitext(type_img)[0])

        size_img = content.find("img", src=re.compile("\/icons\/container\/"))
        self.size = Size.from_string(size_img.get("alt").split(": ")[1])

        D_and_T_img = content.find("p", "Meta DiffTerr").find_all("img")
        self.difficulty, self.terrain = [
            float(img.get("alt").split()[0]) for img in D_and_T_img
        ]

        # TODO do NOT use English phrases like "Placed by" to search for attributes

        self.author = content.find(
            "p", text=re.compile("Placed by:")).text.split("\r\n")[2].strip()

        hidden_p = content.find("p", text=re.compile("Placed Date:"))
        self.hidden = hidden_p.text.replace("Placed Date:", "").strip()

        attr_img = content.find_all("img", src=re.compile("\/attributes\/"))
        attributes_raw = [
            os.path.basename(_.get("src")).rsplit("-", 1) for _ in attr_img
        ]
        self.attributes = {
            name: appendix.startswith("yes") for name, appendix
            in attributes_raw if not appendix.startswith("blank")
        }

        self.summary = content.find(
            "h2", text="Short Description").find_next("div").text

        self.description = content.find(
            "h2", text="Long Description").find_next("div").text

        self.hint = content.find(id="uxEncryptedHint").text

        self.favorites = content.find(
            "strong", text=re.compile("Favorites:")).parent.text.split()[-1]

        self.waypoints = Waypoint.from_html(content, "Waypoints")

        self.log_counts = Cache._get_log_counts_from_print_page(res)

    @staticmethod
    def _get_log_counts_from_cache_details(soup):
        """Return a dictionary of all log counts found in the page
        representation, based on the cache details page.

        :param bs4.BeautifulSoup soup: Parsed html document of the cache details page.
        """
        lbl_find_counts = soup.find("span", {"id": "ctl00_ContentBody_lblFindCounts"})
        log_totals = lbl_find_counts.find("p", "LogTotals")

        # Text gives numbers separated by a lot of spaces, splitting retrieves the numbers.
        # The values might contain thousand separators, which we have to remove before converting
        # them to real numbers.
        values = log_totals.text.split()
        values = [int(value.replace(",", "").replace(".", "")) for value in values]

        # Retrieve the list of image sources.
        images = log_totals.find_all("img")
        types = []
        for image in images:
            type = image["src"]  # "../images/logtypes/2.png"
            type = type.split("/")[-1].split(".")[0]  # "2"
            type = LogType.from_filename(type)
            types.append(type)

        # Prevent possible wrong assignments when the list sizes differ for some unknown reason.
        if not len(values) == len(types):
            raise errors.ValueError(
                "Different list sizes getting log counts: {} types and {} counts.".format(
                    len(types), len(values)))

        # Finally create the mapping.
        log_counts = dict(zip(types, values))

        return log_counts

    @staticmethod
    def _get_log_counts_from_print_page(soup):
        """Return a dictionary of all log counts found in the page
        representation, based on the print page.

        :param bs4.BeautifulSoup soup: Parsed html document of the cache print page.
        """
        # The print page does not use any IDs, so we use some more complicated approach here and
        # search for the paragraph containing the log type images.
        p_meta = soup.find_all("p", "Meta")
        element = None
        for entry in p_meta:
            if "images/logtypes" in str(entry):
                element = entry
                break

        if not element:
            raise errors.ValueError("Log counts could not be found.")

        # Text gives numbers and verbose descriptions of the current values as well as an
        # introductory text. So we have to perform number checks for each element and only keep
        # the numbers.
        # The values might contain thousand separators, which we have to remove before converting
        # them to real numbers.
        words = element.text.split()
        values = []
        for word in words:
            word = word.replace(",", "").replace(".", "")
            if word and word.isdigit():
                values.append(int(word))

        # Retrieve the list of image sources.
        images = element.find_all("img")
        types = []
        for image in images:
            type = image["src"]  # "../images/logtypes/2.png"
            type = type.split("/")[-1].split(".")[0]  # "2"
            type = LogType.from_filename(type)
            types.append(type)

        # Prevent possible wrong assignments when the list sizes differ for some unknown reason.
        if not len(values) == len(types):
            raise errors.ValueError(
                "Different list sizes getting log counts: {} types and {} counts.".format(
                    len(types), len(values)))

        # Finally create the mapping.
        log_counts = dict(zip(types, values))

        return log_counts

    def _logbook_get_page(self, page=0, per_page=25):
        """Load one page from logbook.

        :param int page: Logbook page to load.
        :param int per_page: Logs per page (used to calculate start index).
        :raise .LoadError: If loading fails.
        """
        res = self.geocaching._request(self._urls["logbook"], params={
            "tkn": self._logbook_token,  # will trigger lazy_loading if needed
            "idx": int(page) + 1,  # Groundspeak indexes this from 1 (OMG..)
            "num": int(per_page),
            "decrypt": "true"
        }, expect="json")

        if res["status"] != "success":
            error_msg = res["msg"] if "msg" in res else "Unknown error"
            raise errors.LoadError("Logbook cannot be loaded: {}".format(error_msg))

        return res["data"]

    def load_logbook(self, limit=float("inf")):
        """Return a generator of logs for this cache.

        Yield instances of :class:`.Log` filled with log data.

        :param int limit: Maximum number of logs to generate.
        """
        logging.info("Loading logbook for {}...".format(self))

        page = 0
        per_page = min(limit, 100)  # max number to fetch in one request is 100 items

        while True:
            # get one page
            logbook_page = self._logbook_get_page(page, per_page)
            page += 1

            if not logbook_page:
                # result is empty - no more logs
                return

            for log_data in logbook_page:

                limit -= 1  # handle limit
                if limit < 0:
                    return

                img_filename = log_data["LogTypeImage"].rsplit(".", 1)[0]  # filename w/o extension

                # create and fill log object
                l = Log()
                l.type = LogType.from_filename(img_filename)
                l.text = log_data["LogText"]
                l.visited = log_data["Visited"]
                l.author = log_data["UserName"]
                yield l

    # TODO: trackable list can have multiple pages - handle it in similar way as _logbook_get_page
    # for example see: http://www.geocaching.com/geocache/GC26737_geocaching-jinak-tb-gc-hrbitov
    def load_trackables(self, limit=float("inf")):
        """Return a generator of trackables in this cache.

        Yield instances of :class:`.Trackable` filled with trackable data.

        :param int limit: Maximum number of trackables to generate.
        """
        logging.info("Loading trackables for {}...".format(self))
        self.trackables = []

        url = self._trackable_page_url  # will trigger lazy_loading if needed
        if not url:
            # no link to all trackables = no trackables in cache
            return
        res = self.geocaching._request(url)

        trackable_table = res.find_all("table")[1]
        links = trackable_table.find_all("a")
        # filter out all urls for trackables
        urls = [link.get("href") for link in links if "track" in link.get("href")]
        # find the names matching the trackble urls
        names = [re.split("[\<\>]", str(link))[2] for link in links if "track" in link.get("href")]

        for name, url in zip(names, urls):

            limit -= 1  # handle limit
            if limit < 0:
                return

            # create and fill trackable object
            t = Trackable(self.geocaching, None)
            t.name = name
            t.url = url
            self.trackables.append(t)
            yield t

    def _get_log_page_url(self):
        return self._urls["log_page"].format(wp=self.wp.lower())

    def _load_log_page(self):
        """Load a logging page for this cache.

        :return: Tuple of data nescessary to log the cache.
        :rtype: :class:`tuple` of (:class:`set`:, :class:`dict`, class:`str`)
        """
        log_page = self.geocaching._request(self._get_log_page_url())

        # find all valid log types for the cache
        valid_types = {o["value"] for o in log_page.find("select", attrs={"name": "LogTypeId"}).find_all("option")}

        # find all static data fields needed for log
        hidden_inputs = log_page.find_all("input", type=["hidden", "submit"])
        hidden_inputs = {i["name"]: i.get("value", "") for i in hidden_inputs}

        return valid_types, hidden_inputs

    def post_log(self, log):
        """Post a log for this cache.

        :param .Log log: Previously created :class:`Log` filled with data.
        """
        if not log.text:
            raise errors.ValueError("Log text is empty")

        valid_types, hidden_inputs = self._load_log_page()
        if log.type.value not in valid_types:
            raise errors.ValueError("The cache does not accept this type of log")

        # assemble post data
        post = hidden_inputs
        post["LogTypeId"] = log.type.value
        post["LogDate"] = log.visited.strftime("%Y-%m-%d")
        post["LogText"] = log.text

        self.geocaching._request(self._get_log_page_url(), method="POST", data=post)

        self.found_status = log


class Waypoint(object):
    """Waypoint represents a waypoint related to the cache. This may be a
       Parking spot, a stage in a multi-cache or similar.

       :param str identifier: the unique identifier of the location
       :param str type: type of waypoint
       :param Point location: waypoint coordinates
       :param str note: Information about the waypoint
    """
    def __init__(self, id=None, type=None, location=None, note=None):
        self._identifier = id
        self._type = type
        self._location = location
        self._note = note

    @classmethod
    def from_html(cls, soup, table_id):
        """Return a dictionary of all waypoints found in the page
        representation

        :param bs4.BeautifulSoup soup: parsed html document containing the
            waypoints table
        :param str table_id: html id of the waypoints table
        """
        waypoints_dict = {}
        waypoints_table = soup.find('table', id=table_id)
        if waypoints_table:
            waypoints_table = waypoints_table.find_all("tr")
            for r1, r2 in zip(waypoints_table[1::2], waypoints_table[2::2]):
                columns = r1.find_all("td") + r2.find_all("td")
                identifier = columns[3].text.strip()
                type = columns[1].find("img").get("title")
                location_string = columns[5].text.strip()
                try:
                    loc = Point(location_string)
                except ValueError:
                    loc = None
                    logging.debug("No valid location format in waypoint {}: {}".format(
                        identifier, location_string))
                note = columns[8].text.strip()
                waypoints_dict[identifier] = cls(identifier, type, loc, note)
        return waypoints_dict

    def __str__(self):
        return self.identifier

    @property
    def identifier(self):
        """The waypoint unique identifier.

        :type: :class:`str`
        """
        return self._identifier

    @identifier.setter
    def identifier(self, identifier):
        self._identifier = identifier

    @property
    def type(self):
        """The waypoint type.

        :type: :class:`str`
        """
        return self._type

    @type.setter
    def type(self, type):
        self._type = type

    @property
    def location(self):
        """The waypoint location.

        :type: :class:`.Point`
        """
        return self._location

    @location.setter
    def location(self, location):
        if isinstance(location, str):
            location = Point.from_string(location)
        elif not isinstance(location, Point):
            raise errors.ValueError(
                "Passed object is not Point instance nor string containing coordinates.")
        self._location = location

    @property
    def note(self):
        """Any additional information about the waypoint.

        :type: :class:`str`
        """
        return self._note

    @note.setter
    def note(self, note):
        self._note = note


class Type(enum.Enum):
    """Enum of possible cache types.

    according to
        * https://www.geocaching.com/app/ui-icons/sprites/cache-types.svg
        * https://www.geocaching.com/about/cache_types.aspx
    """

    traditional = "2"
    multicache = "3"
    mystery = unknown = puzzle = "8"
    letterbox = "5"
    event = "6"
    mega_event = "453"
    giga_event = "7005"
    earthcache = "137"
    cito = cache_in_trash_out_event = "13"
    webcam = "11"
    virtual = "4"
    wherigo = "1858"
    lost_and_found_event = community_celebration = "3653"
    project_ape = "9"
    geocaching_hq = groundspeak_hq = "3773"
    gps_adventures_exhibit = gps_maze = "1304"
    groundspeak_block_party = "4738"
    locationless = reverse = "12"
    hq_celebration = "3774"

    @classmethod
    def from_filename(cls, filename):
        """Return a cache type from its image filename.

           Values are cache image filenames - http://www.geocaching.com/images/WptTypes/[VALUE].gif
        """
        # fuck Groundspeak, they sometimes use 2 exactly same icons with 2 different names
        name_mapping = {
            "ape_32": "9",
            "earthcache": "137",
            "mega": "453",
            "10Years_32": "3653",
            "HQ_32": "3773",
            "giga": "7005"
        }
        if filename in name_mapping:
            filename = name_mapping[filename]
        return cls(filename)

    @classmethod
    def from_string(cls, name):
        """Return a cache type from its human readable name.

        :raise .ValueError: If cache type cannot be determined.
        """
        name = name.replace(" Geocache", "")  # with space!
        name = name.replace(" Cache", "")  # with space!
        name = name.lower().strip()

        name_mapping = {
            "traditional": cls.traditional,
            "multi-cache": cls.multicache,
            "mystery": cls.mystery,
            "unknown": cls.unknown,
            "letterbox hybrid": cls.letterbox,
            "event": cls.event,
            "mega-event": cls.mega_event,
            "giga-event": cls.giga_event,
            "earthcache": cls.earthcache,
            "cito": cls.cito,
            "cache in trash out event": cls.cache_in_trash_out_event,
            "webcam": cls.webcam,
            "virtual": cls.virtual,
            "wherigo": cls.wherigo,
            "lost and found event": cls.community_celebration,
            "project ape": cls.project_ape,
            "geocaching hq": cls.geocaching_hq,
            "groundspeak hq": cls.geocaching_hq,
            "gps adventures exhibit": cls.gps_adventures_exhibit,
            "groundspeak block party": cls.groundspeak_block_party,
            "locationless (reverse)": cls.locationless,
            "geocaching hq celebration": cls.hq_celebration,
            "community celebration event": cls.community_celebration
        }

        try:
            return name_mapping[name]
        except KeyError as e:
            raise errors.ValueError("Unknown cache type '{}'.".format(name)) from e


class Size(enum.Enum):
    """Enum of possible cache sizes.

    Naming follows Groundspeak image filenames, values are human readable names.
    """

    micro = "micro"
    small = "small"
    regular = "regular"
    large = "large"
    not_chosen = "not chosen"
    virtual = "virtual"
    other = "other"

    @classmethod
    def from_filename(cls, filename):
        """Return a cache size from its image filename."""
        return cls[filename]

    @classmethod
    def from_string(cls, name):
        """Return a cache size from its human readable name.

        :raise .ValueError: If cache size cannot be determined.
        """
        name = name.strip().lower()

        try:
            return cls(name)
        except ValueError as e:
            raise errors.ValueError("Unknown cache size '{}'.".format(name)) from e

    @classmethod
    def from_number(cls, number):
        """Return a cache size from its numeric id.

        :raise .ValueError: If cache size cannot be determined.
        """
        number = int(number)

        number_mapping = {
            2: cls.micro,
            8: cls.small,
            3: cls.regular,
            4: cls.large,
            6: cls.other
        }

        try:
            return number_mapping[number]
        except KeyError as e:
            raise errors.ValueError("Unknown cache size numeric id '{}'.".format(number)) from e


class CountryClassUnknownName(ValueError):
    pass


class CountryClassUnknownCombination(ValueError):
    pass


class CountryClassAmbiguityValue(ValueError):
    pass


class Country:

    __countries = {
          2: 'United States',
          3: 'Australia',
          4: 'Belgium',
          5: 'Canada',
          6: 'Chile',
          7: 'Ireland',
          8: 'Luxembourg',
          9: 'New Zealand',
         10: 'Sweden',
         11: 'United Kingdom',
         12: 'Afghanistan',
         13: 'Antigua and Barbuda',
         14: 'Algeria',
         15: 'Armenia',
         16: 'Andorra',
         17: 'Angola',
         18: 'Antarctica',
         19: 'Argentina',
         20: 'Aruba',
         21: 'Azerbaijan',
         23: 'Bahamas',
         24: 'Bangladesh',
         25: 'Barbados',
         26: 'Benin',
         27: 'Bermuda',
         29: 'Bahrain',
         30: 'Bhutan',
         31: 'Belize',
         32: 'Bolivia',
         33: 'Botswana',
         34: 'Brazil',
         35: 'Burundi',
         36: 'Brunei',
         37: 'Bulgaria',
         39: 'British Virgin Islands',
         40: 'Belarus',
         41: 'New Caledonia',
         42: 'Cambodia',
         43: 'Cameroon',
         44: 'Cayman Islands',
         46: 'Central African Republic',
         47: 'China',
         48: 'Cook Islands',
         49: 'Colombia',
         50: 'Comoros',
         51: 'Congo',
         52: 'Costa Rica',
         53: 'Croatia',
         54: 'Curaçao',
         55: 'Cyprus',
         56: 'Czechia',
         57: 'Denmark',
         58: 'Djibouti',
         59: 'Dominica',
         60: 'Dominican Republic',
         61: 'Ecuador',
         62: 'Equatorial Guinea',
         63: 'Egypt',
         64: 'El Salvador',
         65: 'Eritrea',
         66: 'Estonia',
         67: 'Ethiopia',
         68: 'Faroe Islands',
         69: 'Falkland Islands',
         70: 'French Guiana',
         71: 'Fiji',
         72: 'Finland',
         73: 'France',
         74: 'French Polynesia',
         75: 'Gabon',
         76: 'Gambia',
         77: 'Guadeloupe',
         78: 'Georgia',
         79: 'Germany',
         80: 'Gibraltar',
         81: 'Grenada',
         82: 'Greece',
         83: 'Greenland',
         84: 'Guatemala',
         85: 'Guinea-Bissau',
         86: 'Guernsey',
         87: 'Guyana',
         89: 'Haiti',
         90: 'Honduras',
         91: 'Hong Kong',
         92: 'Hungary',
         93: 'Iceland',
         94: 'India',
         95: 'Indonesia',
         96: 'Iran',
         97: 'Iraq',
         98: 'Israel',
         99: 'Italy',
        100: 'Côte d\'Ivoire',
        101: 'Jamaica',
        102: 'Jersey',
        103: 'Jordan',
        104: 'Japan',
        106: 'Kazakhstan',
        107: 'Kenya',
        108: 'Kyrgyzstan',
        109: 'Kiribati',
        110: 'Laos',
        111: 'Latvia',
        112: 'Libya',
        113: 'Lebanon',
        114: 'Lesotho',
        115: 'Liberia',
        116: 'Liechtenstein',
        117: 'Lithuania',
        119: 'Madagascar',
        121: 'Malaysia',
        122: 'Martinique',
        123: 'Mauritania',
        124: 'Maldives',
        125: 'North Macedonia',
        127: 'Mali',
        128: 'Malta',
        129: 'Malawi',
        130: 'Monaco',
        131: 'Mongolia',
        132: 'Morocco',
        133: 'Mozambique',
        134: 'Mauritius',
        135: 'Montserrat',
        136: 'Myanmar',
        137: 'Namibia',
        138: 'Nauru',
        140: 'Nepal',
        141: 'Netherlands',
        143: 'Niger',
        144: 'Nicaragua',
        145: 'Nigeria',
        146: 'North Korea',
        147: 'Norway',
        149: 'Niue',
        150: 'Oman',
        151: 'Pakistan',
        152: 'Panama',
        153: 'Peru',
        154: 'Philippines',
        155: 'Pitcairn',
        156: 'Papua New Guinea',
        158: 'Poland',
        159: 'Portugal',
        160: 'Qatar',
        161: 'Réunion',
        162: 'Romania',
        163: 'Russia',
        164: 'Rwanda',
        165: 'South Africa',
        166: 'Saudi Arabia',
        167: 'Senegal',
        168: 'Seychelles',
        169: 'Saint Barthélemy',
        171: 'Saint Helena',
        173: 'Saint Lucia',
        174: 'Saint Martin',
        175: 'Saint Pierre and Miquelon',
        176: 'Sao Tome and Principe',
        177: 'Saint Vincent and the Grenadines',
        178: 'Sierra Leone',
        179: 'Singapore',
        180: 'South Korea',
        181: 'Slovenia',
        182: 'Slovakia',
        183: 'San Marino',
        184: 'Solomon Islands',
        185: 'Somalia',
        186: 'Spain',
        187: 'Sri Lanka',
        188: 'Sudan',
        189: 'Suriname',
        190: 'Swaziland',
        192: 'Switzerland',
        193: 'Syria',
        194: 'Taiwan',
        195: 'Tajikistan',
        196: 'Tanzania',
        197: 'Turks and Caicos Islands',
        198: 'Thailand',
        199: 'Turkmenistan',
        200: 'Togo',
        201: 'Tonga',
        202: 'Trinidad and Tobago',
        203: 'Tunisia',
        204: 'Turkey',
        205: 'Tuvalu',
        206: 'United Arab Emirates',
        207: 'Ukraine',
        208: 'Uganda',
        210: 'Uruguay',
        211: 'Uzbekistan',
        212: 'Vanuatu',
        213: 'Vatican City State',
        214: 'Venezuela',
        215: 'Vietnam',
        216: 'Burkina Faso',
        217: 'Samoa',
        218: 'Wallis and Futuna Islands',
        220: 'Yemen',
        222: 'Serbia',
        224: 'Zambia',
        225: 'Zimbabwe',
        226: 'Puerto Rico',
        227: 'Austria',
        228: 'Mexico',
        229: 'Guam',
        234: 'Bosnia and Herzegovina',
        235: 'US Virgin Islands',
        236: 'Northern Mariana Islands',
        237: 'Moldova',
        238: 'Cuba',
        239: 'Cabo Verde',
        240: 'Marshall Islands',
        241: 'Kuwait',
        242: 'Micronesia',
        243: 'Isle of Man',
        244: 'Albania',
        245: 'American Samoa',
        246: 'Anguilla',
        247: 'Bouvet Island',
        248: 'British Indian Ocean Territory',
        249: 'Chad',
        250: 'Christmas Island',
        251: 'Cocos (Keeling) Islands',
        252: 'Timor-Leste',
        253: 'French Southern and Antarctic Territories',
        254: 'Ghana',
        255: 'Guinea',
        256: 'Heard Island and McDonald Islands',
        257: 'Democratic Republic of the Congo',
        258: 'Macao',
        259: 'Mayotte',
        260: 'Norfolk Island',
        261: 'Palau',
        262: 'Paraguay',
        264: 'Saint Kitts and Nevis',
        267: 'South Georgia and the South Sandwich Islands',
        268: 'Svalbard and Jan Mayen Islands',
        269: 'Tokelau',
        270: 'US Minor Outlying Islands',
        271: 'Western Sahara',
        272: 'Aland Islands',
        274: 'Montenegro',
        276: 'Palestine',
        278: 'South Sudan',
        279: 'Bonaire, Sint Eustatius and Saba',
        280: 'Sark',
        281: 'Sint Maarten',
    }
    __states = {
        2: "Alaska",
        3: "Arizona",
        4: "Arkansas",
        5: "California",
        6: "Colorado",
        7: "Connecticut",
        8: "District of Columbia",
        9: "Delaware",
        10: "Florida",
        11: "Georgia",
        12: "Hawaii",
        13: "Idaho",
        14: "Illinois",
        15: "Indiana",
        16: "Iowa",
        17: "Kansas",
        18: "Kentucky",
        19: "Louisiana",
        20: "Maine",
        21: "Maryland",
        22: "Massachusetts",
        23: "Michigan",
        24: "Minnesota",
        25: "Mississippi",
        26: "Missouri",
        27: "Montana",
        28: "Nebraska",
        29: "Nevada",
        30: "New Hampshire",
        31: "New Jersey",
        32: "New Mexico",
        33: "New York",
        34: "North Carolina",
        35: "North Dakota",
        36: "Ohio",
        37: "Oklahoma",
        38: "Oregon",
        39: "Pennsylvania",
        40: "Rhode Island",
        41: "South Carolina",
        42: "South Dakota",
        43: "Tennessee",
        44: "Texas",
        45: "Utah",
        46: "Vermont",
        47: "Virginia",
        48: "Washington",
        49: "West Virginia",
        50: "Wisconsin",
        51: "Wyoming",
        52: "New South Wales",
        53: "Victoria",
        54: "Queensland",
        55: "South Australia",
        56: "Western Australia",
        57: "Tasmania",
        58: "Northern Territory",
        59: "Australian Capital Territory",
        60: "Alabama",
        62: "Québec",
        63: "Alberta",
        64: "British Columbia",
        65: "Manitoba",
        66: "New Brunswick",
        67: "Newfoundland and Labrador",
        68: "Nova Scotia",
        69: "Ontario",
        70: "Prince Edward Island",
        71: "Saskatchewan",
        72: "Northwest Territories",
        73: "Nunavut",
        74: "Yukon Territory",
        76: "Oost-Vlaanderen",
        78: "Vlaams-Brabant",
        80: "Liège",
        81: "Namur",
        82: "North Island",
        86: "South Island",
        87: "Antwerpen",
        88: "Hainaut",
        89: "Limburg",
        90: "Luxembourg",
        91: "Brabant wallon",
        92: "West-Vlaanderen",
        93: "Brussels",
        95: "Aveiro",
        96: "Beja",
        97: "Braga",
        98: "Bragança",
        99: "Castelo Branco",
        100: "Coimbra",
        101: "Évora",
        102: "Faro",
        103: "Guarda",
        104: "Leiria",
        105: "Lisboa",
        106: "Portalegre",
        107: "Porto",
        108: "Santarém",
        109: "Setúbal",
        110: "Viana do Castelo",
        111: "Viseu",
        112: "Vila Real",
        113: "Arquipélago da Madeira",
        114: "Arquipélago dos Açores",
        115: "Castilla y León",
        116: "Andalucía",
        117: "Castilla-La Mancha",
        119: "Aragón",
        120: "Extremadura",
        121: "Cataluña",
        122: "Galicia",
        123: "Comunidad Valenciana",
        124: "Región de Murcia",
        125: "Principado de Asturias",
        126: "Comunidad Foral de Navarra",
        127: "Comunidad de Madrid",
        128: "Islas Canarias",
        129: "País Vasco",
        130: "Cantabria",
        131: "La Rioja",
        132: "Islas Baleares",
        133: "Ceuta",
        134: "Melilla",
        135: "Baden-Württemberg",
        136: "Bayern",
        137: "Berlin",
        138: "Brandenburg",
        139: "Bremen",
        140: "Hamburg",
        141: "Mecklenburg-Vorpommern",
        142: "Niedersachsen",
        143: "Nordrhein-Westfalen",
        144: "Rheinland-Pfalz",
        145: "Saarland",
        146: "Sachsen",
        147: "Sachsen-Anhalt",
        148: "Schleswig-Holstein",
        149: "Thüringen",
        150: "Hessen",
        152: "Western Cape",
        153: "Eastern Cape",
        154: "Northern Cape",
        155: "Mpumalanga",
        156: "North West",
        157: "Kwazulu Natal",
        158: "Limpopo",
        159: "Gauteng",
        160: "Free State",
        162: "Acre",
        163: "Alagoas",
        164: "Amapá",
        165: "Amazonas",
        166: "Bahia",
        167: "Ceará",
        168: "Distrito Federal",
        169: "Espírito Santo",
        170: "Goiás",
        171: "Maranhão",
        172: "Mato Grosso",
        173: "Mato Grosso do Sul",
        174: "Minas Gerais",
        175: "Pará",
        176: "Paraíba",
        177: "Paraná",
        178: "Pernambuco",
        179: "Piauí",
        180: "Rio de Janeiro",
        181: "Rio Grande do Norte",
        182: "Rio Grande do Sul",
        183: "Rondônia",
        184: "Roraima",
        185: "Santa Catarina",
        186: "São Paulo",
        187: "Sergipe",
        188: "Tocantins",
        189: "Abruzzo",
        190: "Basilicata",
        192: "Calabria",
        193: "Campania",
        194: "Emilia–Romagna",
        195: "Friuli–Venezia Giulia",
        196: "Lazio",
        197: "Liguria",
        198: "Lombardia",
        199: "Marche",
        200: "Molise",
        201: "Piemonte",
        202: "Puglia",
        203: "Sardegna",
        204: "Sicilia",
        205: "Toscana",
        206: "Trentino–Alto Adige",
        207: "Umbria",
        208: "Valle d'Aosta",
        209: "Veneto",
        210: "Northern Scotland",
        211: "Southern Scotland",
        212: "North East England",
        213: "North West England",
        214: "Yorkshire",
        215: "East Midlands",
        216: "West Midlands",
        217: "North Wales",
        218: "South Wales",
        219: "Eastern England",
        220: "London",
        221: "Southern England",
        222: "South West England",
        223: "South East England",
        224: "Ulster",
        225: "Munster",
        226: "Dublin",
        227: "Connacht",
        228: "Leinster",
        241: "Oslo",
        249: "Rogaland",
        252: "Møre og Romsdal",
        255: "Nordland",
        258: "Burgenland",
        259: "Kärnten",
        260: "Niederösterreich",
        261: "Oberösterreich",
        262: "Salzburg",
        263: "Steiermark",
        264: "Tirol",
        265: "Vorarlberg",
        273: "Jihomoravský kraj",
        274: "Jihočeský kraj",
        275: "Královéhradecký kraj",
        276: "Karlovarský kraj",
        277: "Liberecký kraj",
        278: "Olomoucký kraj",
        279: "Moravskoslezský kraj",
        280: "Pardubický kraj",
        281: "Plzeňský kraj",
        282: "Středočeský kraj",
        283: "Ústecký kraj",
        284: "Kraj Vysočina",
        285: "Zlínský kraj",
        286: "Hlavní město Praha",
        287: "Banskobystrický kraj",
        288: "Bratislavský kraj",
        289: "Košický kraj",
        290: "Nitriansky kraj",
        291: "Prešovský kraj",
        292: "Trenčiansky kraj",
        293: "Trnavský kraj",
        294: "Žilinský kraj",
        295: "Wien",
        296: "Seoul",
        297: "Busan",
        298: "Daegu",
        299: "Incheon",
        300: "Gwangju",
        301: "Daejeon",
        302: "Ulsan",
        303: "Gyeonggido",
        304: "Gangwondo",
        305: "Chungcheong buk do",
        306: "Chungcheong nam do",
        307: "Jeolla buk do",
        308: "Jeolla nam do",
        309: "Gyeongsang buk do",
        310: "Gyeongsang nam do",
        311: "Jejudo",
        312: "Aichi",
        313: "Aomori",
        314: "Chiba",
        315: "Ehime",
        316: "Fukui",
        317: "Fukuoka",
        318: "Fukushima",
        319: "Gifu",
        320: "Gunma",
        321: "Hiroshima",
        322: "Hokkaido",
        323: "Hyogo",
        324: "Ibaraki",
        325: "Ishikawa",
        326: "Iwate",
        327: "Kagawa",
        328: "Kagoshima",
        329: "Kanagawa",
        330: "Kochi",
        331: "Kumamoto",
        332: "Kyoto",
        333: "Mie",
        334: "Miyagi",
        335: "Miyazaki",
        336: "Nagano",
        337: "Nagasaki",
        338: "Nara",
        339: "Niigata",
        340: "Oita",
        341: "Okayama",
        342: "Okinawa",
        343: "Osaka",
        344: "Saga",
        345: "Saitama",
        346: "Shiga",
        347: "Shimane",
        348: "Shizuoka",
        349: "Tochigi",
        350: "Tokushima",
        351: "Tokyo",
        352: "Tottori",
        353: "Toyama",
        354: "Wakayama",
        355: "Yamagata",
        356: "Yamaguchi",
        357: "Yamanashi",
        359: "Blekinge",
        360: "Dalarna",
        361: "Gotland",
        362: "Gävleborg",
        363: "Halland",
        364: "Jämtland",
        365: "Jönköping",
        366: "Kalmar",
        367: "Kronoberg",
        368: "Norrbotten",
        369: "Skåne",
        370: "Stockholm",
        371: "Södermanland",
        372: "Uppsala",
        373: "Värmland",
        374: "Västerbotten",
        375: "Västernorrland",
        376: "Västmanland",
        377: "Västra Götaland",
        378: "Örebro",
        379: "Östergötland",
        383: "Akita",
        384: "Groningen",
        385: "Drenthe",
        386: "Overijssel",
        387: "Gelderland",
        388: "Utrecht",
        389: "Noord-Holland",
        390: "Zuid-Holland",
        391: "Zeeland",
        392: "Noord-Brabant",
        393: "Limburg",
        394: "Friesland",
        395: "Flevoland",
        396: "Dolnośląskie",
        397: "Kujawsko-Pomorskie",
        398: "Lubelskie",
        399: "Lubuskie",
        400: "Łódzkie",
        401: "Małopolskie",
        402: "Mazowieckie",
        403: "Opolskie",
        404: "Podkarpackie",
        405: "Podlaskie",
        406: "Pomorskie",
        407: "Śląskie",
        408: "Świętokrzyskie",
        409: "Warmińsko-Mazurskie",
        410: "Wielkopolskie",
        411: "Zachodniopomorskie",
        416: "Bretagne",
        417: "Centre-Val-de-Loire",
        419: "Corse",
        422: "Île-de-France",
        428: "Pays de la Loire",
        431: "Provence-Alpes-Côte d'Azur",
        434: "Bács-Kiskun",
        435: "Baranya",
        436: "Békés",
        437: "Borsod-Abaúj-Zemplén",
        438: "Budapest",
        439: "Csongrád",
        440: "Fejér",
        441: "Gyor-Moson-Sopron",
        442: "Hajdú-Bihar",
        443: "Heves",
        444: "Jász-Nagykun-Szolnok",
        445: "Komárom-Esztergom",
        446: "Nógrád",
        447: "Pest",
        448: "Somogy",
        449: "Szabolcs-Szatmár-Bereg",
        450: "Tolna",
        451: "Vas",
        452: "Veszprém",
        453: "Zala",
        454: "Aguascalientes",
        455: "Baja California",
        456: "Baja California Sur",
        457: "Campeche",
        458: "Chiapas",
        459: "Chihuahua",
        460: "Coahuila",
        461: "Colima",
        462: "Distrito Federal",
        463: "Durango",
        464: "Guanajuato",
        465: "Guerrero",
        466: "Hidalgo",
        467: "Jalisco",
        468: "México",
        469: "Michoacán",
        470: "Morelos",
        471: "Nayarit",
        472: "Nuevo León",
        473: "Oaxaca",
        474: "Puebla",
        475: "Querétaro",
        476: "Quintana Roo",
        477: "San Luis Potosí",
        478: "Sinaloa",
        479: "Sonora",
        480: "Tabasco",
        481: "Tamaulipas",
        482: "Tlaxcala",
        483: "Veracruz",
        484: "Yucatán",
        485: "Zacatecas",
        486: "Chatham Islands",
        487: "Normandie",
        488: "Bourgogne-Franche-Comté",
        489: "Grand-Est",
        490: "Occitanie",
        491: "Nouvelle-Aquitaine",
        492: "Hauts-de-France",
        493: "Auvergne-Rhône-Alpes",
        494: "Trøndelag",
        495: "Sejong",
        497: "Aargau",
        498: "Appenzell Ausserrhoden",
        499: "Appenzell Innerrhoden",
        500: "Basel Landschaft",
        501: "Basel Stadt",
        502: "Bern",
        503: "Fribourg",
        504: "Genève",
        505: "Glarus",
        506: "Graubünden",
        507: "Jura",
        508: "Luzern",
        509: "Neuchâtel",
        510: "Nidwalden",
        511: "Obwalden",
        512: "Schaffhausen",
        513: "Schwyz",
        514: "Solothurn",
        515: "St. Gallen",
        516: "Thurgau",
        517: "Ticino",
        518: "Uri",
        519: "Valais",
        520: "Vaud",
        521: "Zug",
        522: "Zürich",
        523: "Bonaire",
        524: "Sint Eustatius",
        525: "Saba",
        526: "Vestland",
        527: "Agder",
        528: "Vestfold og Telemark",
        529: "Innlandet",
        530: "Viken",
        531: "Troms og Finnmark"
    }
    __state_to_country = {
        2: 2,
        3: 2,
        4: 2,
        5: 2,
        6: 2,
        7: 2,
        8: 2,
        9: 2,
        10: 2,
        11: 2,
        12: 2,
        13: 2,
        14: 2,
        15: 2,
        16: 2,
        17: 2,
        18: 2,
        19: 2,
        20: 2,
        21: 2,
        22: 2,
        23: 2,
        24: 2,
        25: 2,
        26: 2,
        27: 2,
        28: 2,
        29: 2,
        30: 2,
        31: 2,
        32: 2,
        33: 2,
        34: 2,
        35: 2,
        36: 2,
        37: 2,
        38: 2,
        39: 2,
        40: 2,
        41: 2,
        42: 2,
        43: 2,
        44: 2,
        45: 2,
        46: 2,
        47: 2,
        48: 2,
        49: 2,
        50: 2,
        51: 2,
        52: 3,
        53: 3,
        54: 3,
        55: 3,
        56: 3,
        57: 3,
        58: 3,
        59: 3,
        60: 2,
        62: 5,
        63: 5,
        64: 5,
        65: 5,
        66: 5,
        67: 5,
        68: 5,
        69: 5,
        70: 5,
        71: 5,
        72: 5,
        73: 5,
        74: 5,
        76: 4,
        78: 4,
        80: 4,
        81: 4,
        82: 9,
        86: 9,
        87: 4,
        88: 4,
        89: 4,
        90: 4,
        91: 4,
        92: 4,
        93: 4,
        95: 159,
        96: 159,
        97: 159,
        98: 159,
        99: 159,
        100: 159,
        101: 159,
        102: 159,
        103: 159,
        104: 159,
        105: 159,
        106: 159,
        107: 159,
        108: 159,
        109: 159,
        110: 159,
        111: 159,
        112: 159,
        113: 159,
        114: 159,
        115: 186,
        116: 186,
        117: 186,
        119: 186,
        120: 186,
        121: 186,
        122: 186,
        123: 186,
        124: 186,
        125: 186,
        126: 186,
        127: 186,
        128: 186,
        129: 186,
        130: 186,
        131: 186,
        132: 186,
        133: 186,
        134: 186,
        135: 79,
        136: 79,
        137: 79,
        138: 79,
        139: 79,
        140: 79,
        141: 79,
        142: 79,
        143: 79,
        144: 79,
        145: 79,
        146: 79,
        147: 79,
        148: 79,
        149: 79,
        150: 79,
        152: 165,
        153: 165,
        154: 165,
        155: 165,
        156: 165,
        157: 165,
        158: 165,
        159: 165,
        160: 165,
        162: 34,
        163: 34,
        164: 34,
        165: 34,
        166: 34,
        167: 34,
        168: 34,
        169: 34,
        170: 34,
        171: 34,
        172: 34,
        173: 34,
        174: 34,
        175: 34,
        176: 34,
        177: 34,
        178: 34,
        179: 34,
        180: 34,
        181: 34,
        182: 34,
        183: 34,
        184: 34,
        185: 34,
        186: 34,
        187: 34,
        188: 34,
        189: 99,
        190: 99,
        192: 99,
        193: 99,
        194: 99,
        195: 99,
        196: 99,
        197: 99,
        198: 99,
        199: 99,
        200: 99,
        201: 99,
        202: 99,
        203: 99,
        204: 99,
        205: 99,
        206: 99,
        207: 99,
        208: 99,
        209: 99,
        210: 11,
        211: 11,
        212: 11,
        213: 11,
        214: 11,
        215: 11,
        216: 11,
        217: 11,
        218: 11,
        219: 11,
        220: 11,
        221: 11,
        222: 11,
        223: 11,
        224: 7,
        225: 7,
        226: 7,
        227: 7,
        228: 7,
        241: 147,
        249: 147,
        252: 147,
        255: 147,
        258: 227,
        259: 227,
        260: 227,
        261: 227,
        262: 227,
        263: 227,
        264: 227,
        265: 227,
        273: 56,
        274: 56,
        275: 56,
        276: 56,
        277: 56,
        278: 56,
        279: 56,
        280: 56,
        281: 56,
        282: 56,
        283: 56,
        284: 56,
        285: 56,
        286: 56,
        287: 182,
        288: 182,
        289: 182,
        290: 182,
        291: 182,
        292: 182,
        293: 182,
        294: 182,
        295: 227,
        296: 180,
        297: 180,
        298: 180,
        299: 180,
        300: 180,
        301: 180,
        302: 180,
        303: 180,
        304: 180,
        305: 180,
        306: 180,
        307: 180,
        308: 180,
        309: 180,
        310: 180,
        311: 180,
        312: 104,
        313: 104,
        314: 104,
        315: 104,
        316: 104,
        317: 104,
        318: 104,
        319: 104,
        320: 104,
        321: 104,
        322: 104,
        323: 104,
        324: 104,
        325: 104,
        326: 104,
        327: 104,
        328: 104,
        329: 104,
        330: 104,
        331: 104,
        332: 104,
        333: 104,
        334: 104,
        335: 104,
        336: 104,
        337: 104,
        338: 104,
        339: 104,
        340: 104,
        341: 104,
        342: 104,
        343: 104,
        344: 104,
        345: 104,
        346: 104,
        347: 104,
        348: 104,
        349: 104,
        350: 104,
        351: 104,
        352: 104,
        353: 104,
        354: 104,
        355: 104,
        356: 104,
        357: 104,
        359: 10,
        360: 10,
        361: 10,
        362: 10,
        363: 10,
        364: 10,
        365: 10,
        366: 10,
        367: 10,
        368: 10,
        369: 10,
        370: 10,
        371: 10,
        372: 10,
        373: 10,
        374: 10,
        375: 10,
        376: 10,
        377: 10,
        378: 10,
        379: 10,
        383: 104,
        384: 141,
        385: 141,
        386: 141,
        387: 141,
        388: 141,
        389: 141,
        390: 141,
        391: 141,
        392: 141,
        393: 141,
        394: 141,
        395: 141,
        396: 158,
        397: 158,
        398: 158,
        399: 158,
        400: 158,
        401: 158,
        402: 158,
        403: 158,
        404: 158,
        405: 158,
        406: 158,
        407: 158,
        408: 158,
        409: 158,
        410: 158,
        411: 158,
        416: 73,
        417: 73,
        419: 73,
        422: 73,
        428: 73,
        431: 73,
        434: 92,
        435: 92,
        436: 92,
        437: 92,
        438: 92,
        439: 92,
        440: 92,
        441: 92,
        442: 92,
        443: 92,
        444: 92,
        445: 92,
        446: 92,
        447: 92,
        448: 92,
        449: 92,
        450: 92,
        451: 92,
        452: 92,
        453: 92,
        454: 228,
        455: 228,
        456: 228,
        457: 228,
        458: 228,
        459: 228,
        460: 228,
        461: 228,
        462: 228,
        463: 228,
        464: 228,
        465: 228,
        466: 228,
        467: 228,
        468: 228,
        469: 228,
        470: 228,
        471: 228,
        472: 228,
        473: 228,
        474: 228,
        475: 228,
        476: 228,
        477: 228,
        478: 228,
        479: 228,
        480: 228,
        481: 228,
        482: 228,
        483: 228,
        484: 228,
        485: 228,
        486: 9,
        487: 73,
        488: 73,
        489: 73,
        490: 73,
        491: 73,
        492: 73,
        493: 73,
        494: 147,
        495: 180,
        497: 192,
        498: 192,
        499: 192,
        500: 192,
        501: 192,
        502: 192,
        503: 192,
        504: 192,
        505: 192,
        506: 192,
        507: 192,
        508: 192,
        509: 192,
        510: 192,
        511: 192,
        512: 192,
        513: 192,
        514: 192,
        515: 192,
        516: 192,
        517: 192,
        518: 192,
        519: 192,
        520: 192,
        521: 192,
        522: 192,
        523: 279,
        524: 279,
        525: 279,
        526: 147,
        527: 147,
        528: 147,
        529: 147,
        530: 147,
        531: 147
    }

    @classmethod
    def countries(cls):
        return cls.__countries

    @classmethod
    def states(cls):
        return cls.__states

    @classmethod
    def _invert_dictionary(cls, data):
        inv_map = {}
        for key, value in data.items():
            inv_map[value.lower()] = inv_map.get(value.lower(), []) + [key]
        return inv_map

    @classmethod
    def country_str_id(cls):
        try:
            return cls._country_id_by_name
        except AttributeError:
            cls._country_id_by_name = cls._invert_dictionary(cls.__countries)
            return cls._country_id_by_name

    @classmethod
    def state_str_id(cls):
        try:
            return cls._state_id_by_name
        except AttributeError:
            cls._state_id_by_name = cls._invert_dictionary(cls.__states)
            return cls._state_id_by_name

    def __init__(self, cid=None, sid=None):
        if cid is not None and cid not in self.__countries:
            raise ValueError(f'Country id={cid} unknown')
        if sid is not None and sid not in self.__states:
            raise ValueError(f'State id={sid} unknown')
        if cid is not None and sid is not None and cid != self.__state_to_country[sid]:
            raise ValueError(f'Combination of Country id={cid} and State id={sid} unknown')

        self._cid = self.__state_to_country[sid] if (cid is None and sid is not None) else cid
        self._sid = sid

    def __str__(self):
        if self.has_state:
            return f'{self.state_name}, {self.country_name}'
        return f'{self.country_name}'

    @classmethod
    def ids_by_country_name(cls, name):
        results = cls.country_str_id().get(name.lower().strip(), [])
        return results

    @classmethod
    def ids_by_state_name(cls, name):
        results = cls.state_str_id().get(name.lower().strip(), [])
        return results

    @classmethod
    def from_string_country(cls, name):
        """Return a cache country from its country name."""
        ids = cls.ids_by_country_name(name)
        if len(ids) == 0:
            raise CountryClassUnknownName(f'Country {name} is unknown')
        elif len(ids) > 1:
            raise CountryClassAmbiguityValue(f'Country {name} is ambiguity')

        return Country(cid=ids[0], sid=None)

    @classmethod
    def from_string_state(cls, name):
        """Return a cache country from its state name."""
        ids = cls.ids_by_state_name(name)
        if len(ids) == 0:
            raise CountryClassUnknownName(f'State {name} is unknown')
        elif len(ids) > 1:
            raise CountryClassAmbiguityValue(f'State {name} is ambiguity')

        return Country(cid=None, sid=ids[0])

    @classmethod
    def from_string_country_state(cls, token):
        if len(token) < 2:
            raise ValueError(f'Combination {token} is unknown') ## TODO fehlermeldung

        cid = cls.ids_by_country_name(token[1])
        sids = cls.ids_by_state_name(token[0])

        if not (len(cid) == 1 and len(sids) > 0):
            cid = cls.ids_by_country_name(token[0])
            sids = cls.ids_by_state_name(token[1])

        if not (len(cid) == 1 and len(sids) > 0):
            raise CountryClassUnknownCombination(f'Combination {token} is unknown')

        for sid in sids:
            if cls.__state_to_country[sid] == cid[0]:
                return Country(cid=cid[0], sid=sid)

        raise CountryClassUnknownCombination(f'Combination {token} is unknown')

    @classmethod
    def from_string(cls, name):
        """Return a cache country from its name"""

        """
        Converts a name into a Country object

        The method try to parse the name in following order:
            State, Country
            Country, State
            Country
            State

        :param name:
        :return:
        """
        m = re.match(r'([^,]+),(.+)', name)  # split after the first
        if m:
            try:
                return cls.from_string_country_state((m[1], m[2]))
            except CountryClassUnknownName:
                pass
            except ValueError:
                pass

        try:
            return cls.from_string_country(name)
        except CountryClassUnknownName:
            pass

        try:
            return cls.from_string_state(name)
        except CountryClassUnknownName:
            pass

        raise CountryClassUnknownName(f'{name} is unknown')

    @property
    def country_id(self):
        return self._cid

    @property
    def country_name(self):
        return self.__countries[self._cid] if self._cid else None

    @property
    def state_id(self):
        return self._sid

    @property
    def state_name(self):
        return self.__states[self._sid] if self._sid else None

    @property
    def has_state(self):
        return self._sid is not None
